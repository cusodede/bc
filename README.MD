#Конфигурация

Production-конфиги лежат в `/config`.

Для перекрытия какого-то конфигурационного файла создайте его копию в `/config/local/` (например, `/config/local/db.php` для хранения локальных настроек подключения к БД).

# Установка
~~~
git clone %repo_url% ppl
~~~
где `%repo_url%` - адрес репозитория проекта.

Подключаем БД в db.php
~~~
cd ppl
composer install
composer migrations
~~~

Вход - admin/admin

# Соглашения по структуре
## Всему своё место:

**assets** - глобальные ассеты: модели и ресурсы (смотрим, как сделано, делаем так же).<br />
**commands** - глобальные консольные контроллеры. Пока кладём все вместе, если будет много — разделим.<br />
**config** - все конфиги. Если понадобится сделать конфиг для отдельной сущности, выносим его в отдельный файл для удобства подключения.<br />
**controllers** - глобальные web-контроллеры.<br />
**definitions** - *экспериментальные* описания API для генератора Swagger.<br />
**doc** - произвольная документация. Без ограничений, написали доку - кинули в каталог.<br />
**models** - глобальные модели, разделённые по подкаталогам по назначению:

*    **core** - внутренние штуки для разработки: отладчики, обслуживание.
*    **site** - модели веб-приложения, например, авторизация.
*    **sys** - системные модели приложения.

**modules** - составные части приложения, изолированные друг от друга (но не глобально).<br />
**mail** - шаблоны для почтовых сообщений.<br />
**schema** - описания GraphQL API.<br />
**tests** - тесты PHPUnit.<br />
**views** - глобальные шаблоны. Соблюдаем декларации фреймворка: название файла вью совпадает с именем экшена и лежит в подкаталоге с именем контроллера. Для модальных вью создаём подкаталог.<br />
**widgets** - глобальные виджеты. Смотрим, как сделано, делаем аналогично.<br />

## Стараемся изолировать все сущности.
**Ассеты**: ресурсы каждого ассета дробим по файлам по понятной логике. Стили, например, выносим в разные css, каждый из которых описывает свою часть интерфейса; объединяем ресурсы уже в модели ассета.
**Контроллеры**: контроллер отвечает только за связанную модель. Скажем, если это UsersController, то в нём должно быть **только** управление пользователями, но не пользовательскими сущностями, например.<br />
С ajax-экшенами попробуем делать так:
1) Сначала пытаемся объединить с обычным методом через isAjax:
```php
public function actionProfile(int $id):?string {
    if (null === $user = Users::findModel($id, new NotFoundHttpException())) return null;
    if (Yii::$app->request->isAjax) {
        return $this->renderAjax('modal/profile', [
            'model' => $user
        ]);
    }
    return $this->render('profile', [
        'model' => $user
    ]);
}
```
2) Если объединить нельзя (поведение различается) или не с чем (метод есть только в ajax-версии), делаем его в том же контроллере.
3) Если аяксовой логики слишком много, делаем отдельный контроллер с ajax-суффиксом, например UsersAjaxController. 

**Модели**: всё, что отвечает за взаимодействие с одной сущностью, отделяем в подкаталог, там уже создаём модели, каждая из которых отвечает за один аспект работы. Например:<br />
/users/active_record/Users.php - ActiveRecord-класс взаимодействия с БД, но НЕ логика операций самих пользователей.<br />
/users/Users.php - логика работы пользователей, но НЕ логика взаимодействия с БД.<br />
/users/UsersSearch.php - поисковая модель пользователей.<br />

Хелперы и трейты, связанные с сущностью, располагаем в том же подкаталоге (не возбраняется выделять их в подкаталоги /helpers и /traits), именуем с соответствующими постфиксами: UsersHelper.php, UsersTrait.php

**Модули**: каждый модуль рассматриваем, как мини-приложение, к которому применяются те же правила изоляции внутренностей.

**ActiveRecord**: хорошая практика — отделять логику ActiveRecord, от прочего кода. ActiveRecord-класс должен содержать только логику обслуживания БД: описания атрибутов и релейшенов, допустимы вспомогательные методы, возвращающие ActiveQuery. Всё, что относится к логике за пределами этого, пишется в отдельном классе-наследнике.<br />
Для упрощения понимания структуры, ActiveRecord-класс лучше помещать в подкаталог и отдельный неймспейс, например:
```
@app\models\feature\active_record\Feature.php: class Feature extends ActiveRecord
@app\models\feature\Feature.php: final class Feature extends active_record\Feature
```

**Атрибуты и геттеры**
1) Любое свойство класса, доступ к которому обеспечивается через магические методы ```__get()```/```__set()``` (или, **предпочтительно**, геттеры/сеттеры Yii), должно быть описано в документации класса как @property/@property-read/@property-write. Описание должно включать тип данных свойства и описание его назначения.
2) Сами функции геттеров/сеттеров документируются, как обычно. Указанием на их назначение (т.е., что они "привязаны" к атрибуту) являются префиксы get/set.
3) Для ActiveRecord-атрибутов, получаемых через отношения ```hasOne()```/```hasMany()``` действуют следующие правила:
- Атрибут начинается с префикса **related**, далее содержит название ActiveRecord-класса, к которому устанавливается отношение. Например: ```$relatedUsers```, ```$relatedPermissionsCollections```.
- Если связь устанавливается, как один к одному (через hasOne()), то атрибут типизируется как ```null|%ActiveRecordModelName%```. Если же связь один ко многим (hasMany()) - типизируем, как массив, т.е. ```%ActiveRecordModelName%[]```. Например:
	```php
	@attribute null|Users $relatedUsers Один связанный пользователь
	@attribute PermissionsCollections[] $relatedPermissionsCollections Множество связанных групп доступа
	```
- Геттеры для related-атрибутов **всегда** типизируются, как возвращающие ActiveQuery. Т.е.:
	```php
	/**
	* @return ActiveQuery
	*/
	public function getRelatedUsers():ActiveQuery {
		return $this->hasOne(Users::class, ['id' => 'user_id']);
	}
	
	/**
	* @return ActiveQuery
	*/
	public function getRelatedPermissionsCollections():ActiveQuery {
		return $this->hasMany(PermissionsCollectionsAR::class, ['id' => 'permission_collection_id'])->via('%relation_to_permission_collections_name%');
	}
	```
	*Пояснение:* типы данных для атрибута связи и его геттера в Yii *не совпадают*. Функция всегда возвращает ActiveQuery, а атрибут — результат его выполнения (one()/all() для hasOne()/hasMany()). Таким образом, можно (и нужно) использовать атрибут и его геттер по назначению, в соответствии с этим соглашением. 
 
**```via()``` или ```viaTable()```?**<br />
Только ```via()```.<br />
Хотя связи через ```viaTable()``` зачастую проще и быстрее писать, они менее гибкие и "одноразовые". Связь, описанная свойством и его геттером через ```via()```, во-первых, документирована, во-вторых, может быть переиспользована и отрефакторена, в третьих — ей можно воспользоваться в ```joinWith()```, например.  

# Пишем грамотно
В PHPStorm есть интегрированный плагин для словарной проверки, его использование обязательно. Нет ничего хуже неграмотно названной переменной: другие разработчики будут испытывать трудности, пытаясь сослаться на корректное написание.<br />
При этом не запрещено использование сленга и прочей несловарной терминологии, всё это добавляется в словари по ходу дела.<br />
Также рекомендуется плагин Grazie, обеспечивающий проверку грамотности текста, особенно — если пишете документацию.

# Фичи по коду
Описываем фичи (модули, классы, хелперы, полезняшки, подходы), которые принесли в проект, чтобы знал каждый.<br />

**Работа с модалками**: подключаем ModalHelperAsset, получаем js-методы LoadModal() и AjaxModal():
**LoadModal()**: загружает в тело существующей модалки новый контент из renderAjax-вью.<br />
**AjaxModal()**: загружает renderAjax-вью в контейнер с прелоадером (контейнер создастся, если не существует).

**Системные настройки**: @vendor/pozitronik/yii2-options/src/models/SysOptions.php<br />
Штука для хранения key-value параметров в БД с промежуточным кешированием. Предназначена для выноса параметров из конфига, например, для изменения через интерфейс. Вся дока внутри.

**Пользовательские настройки**: @vendor/pozitronik/yii2-users-options/src/models/UsersOptions.php<br />
Штука для хранения key-value per user параметров в БД с промежуточным кешированием. Этакие серверные кукисы.

**Вывод произвольных множеств**: @vendor/pozitronik/yii2-badgewidget/src/BadgeWidget.php<br />
Виджет, которому на вход можно подать любой произвольный набор данных (от скалярной переменной до массива замыканий), и получить вывод в виде набора bootstrap badge. Оформление вывода можно конфигурировать: вешать на них ссылки, действия, оформление, etc.

## Запуск тестов
Инструменты тестирования и окружение для них будут запускаться в docker-контейнерах, соответственно потребуется локально установленный docker.<br />
Тестовый экземпляр приложения должен работать с отдельной базой данных, нужно создать её локально и прописать подключение в переменных окружения.

Переменные окружения, используемые при сборке контейнеров, должны лежать в файле `.env`. Для референса можно использовать `.env.example`:
```cmd
cp .env.example .env
```
в `.env`, в секции `#tests` прописываем параметры подключения, аналогично тому, как они указываются в конфигах приложения:
```dotenv
#tests - коннекты к БД, используемой при запуске тестов
TEST_DB_NAME=test
TEST_DB_DSN=pgsql:host=localhost;dbname=test
TEST_DB_USER=root
TEST_DB_PASS=password
```

Для удобства все скрипты работы с контейнерами оформлены через алиасы `composer` (см. `composer.json` `"scripts"`) и `make` (см. `Makefile`). Вызовы идентичны, далее указаны примеры для `composer`:
1. `composer down && composer build && composer start` - выключить, пересобрать, запустить контейнеры.
2. `docker exec -it prpl_php bash` - заходим в контейнер с PHP, запуская командную строку, все дальнейшие команды выполняются там. Если есть клиент докера - можно зайти через него, без разницы.
3. `composer create-test-dump` - создать дамп структуры с текущей рабочей БД для последующей заливки его в тестовую БД. В алиасах скриптов данные подключения берутся из `.env`.
4. `composer create-test-database` - создать в тестовой БД структуру базы из подготовленного дампа. Аналогично предыдущему, коннекты парсятся из `.env`.
5. `composer install && composer migrations` - по инструкции выше, ставим пакеты, выполняем миграции.
7. `composer test` - запуск тестов.

Если очень хочется запускать команды локально, не в контейнере, необходимо добавить используемые в докере хосты `mysql`, `postgres`, `chrome` в локальный hosts с ip 127.0.0.1