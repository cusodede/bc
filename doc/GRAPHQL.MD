08.09.21. TODO: описать paginated-поля и добавленные плюхи.

Сделано, в попытке организовать удобную и понятную логику построения схемы. Попутно отрефакторил и код, чтобы неймспейсы классы типов совпадали с тем, как они строятся в схеме.

## Схема

На первый уровень схемы выносятся базовые типы сущностей. Торговые точки, пользователи, тарифы, - грубо говоря все те сущности, что в проекте реализованы отдельным классами. Этот уровень - чисто организационный, ничего иного на него не выносим.
На втором уровне схемы (т.е. внутри сущности) выносим методы (запросы/мутации) с ней связанные. Справочники, перечисления, какие-то удобные фронту запросы.
**Важно**, чтобы при вопросе "мне нужен список кодов операций в журнале _начислений_" в голове сразу возникало понимание "ага, это про _начисления_, значит надо смотреть в `Rewards`"

Этот подход одинаков и для запросов (Query) и для мутаций (Mutation).

### Именование запросов

Запросы именуем в **lowerCamelCase**.
Если запрос возвращает список типов - добавляем ему постфикс `List`: `sellersList`, `usersList`, `rewardsList`, etc.
Типы фильтров (то, что наследуется от `InputObjectType`) именуем в **CamelCase**, добавляя постфикс `FilterInput` к имени фильтруемой сущности: `journalList` => `JournalFilterInput`, `usersList` => `UsersFilterInput`, etc.

### Параметры запросов.

Если запрос возвращает список, то:
1. Обязательно должен присутствовать параметр `(int)limit`, ограничивающий размер выборки результата. Этот параметр обязателен для указания в запросе.
2. Обязательно должен присутствовать параметр `filters` с типом, содержащим набор параметров фильтрации выборки. Параметры в фильтры добавляем по необходимости, в нём могут быть как обязательные параметры, так и нет, сам фильтр тоже может быть как обязателен для указания, так и нет - также исходим из необходимости.
   _(в некоторых списках, в основном тех, что возвращают справочники, фильтров и лимитов ещё нет, но будут)._
3. Опционально может быть добавлен параметр `(int)offset`, учитывающий смещение в выборке результата. Если параметр отсутствует, или не задан, то смещение не делается.

### Связность данных.

Если в объекте, с которым мы работаем, какой-то атрибут является внешним ключом для другого, связанного объекта, то в GQL-типе мы должны работать не со значением атрибута, а со связуемой сущностью. Связуемая сущность не обязательно должна быть каким-то реальным объектом, это может быть какое-то виртуальное представление.
Пример:
Вознаграждения у нас имеют атрибут `(int)status`, который логически выступает в роли внешнего ключа для справочника статусов вознаграждений. Справочника статусов, как объекта в системе не существует, это просто удобная конфигурация, связка `id-имя-всякие_другие_атрибуты`.
В ответе на запрос сущности `Reward` в поле `status` мы должны вернуть не `(int)status`, а связанный объект `RewardStatus`.

## Код

Я попытался отразить в структуре неймспейса `modules/graphql/schema` то, как типы будут проецироваться на схему GraphQL. Организация ещё не финальная, но близка к тому.

`modules/graphql/schema/types` содержит подкаталоги, каждый из которых содержит классы типов, относящиеся к соответствующей сущности:
![изображение](https://user-images.githubusercontent.com/2357892/129718073-55a2a5e3-d7e1-4f5e-928a-96353c241b5d.png)

в `common` находятся общие классы, `QueryType`/`MutationType` - базовые типы запроса/мутации соответственно.

В каждом подкаталоге должен быть класс базового типа, определяющий организацию сущности. Он именуется от этой сущности - `RewardsType` для `rewards`, `ContractsType` для `contracts`, etc. Сам базовый тип ничего не реализует, только перечисляет входящие в него поля в конструкторе, а-ля:

```php

/**
 * Class RewardsType
 *
 * Данные по вознаграждениям
 */
class RewardsType extends BaseObjectType {

	/**
	 * {@inheritdoc}
	 */
	public function __construct() {
		parent::__construct([
			'description' => 'Данные по вознаграждениям и балансу',
			'fields' => [
				'statusList' => StatusListField::field(),
				'stepsStatusList' => StepsStatusListField::field(),
				'journalCodeList' => JournalCodeListField::field(),
				'journalList' => JournalList::field(),
				'rewardsList' => RewardsList::field(),
				'tariffRewardsList' => TariffRewardsList::field()
			]
		]);
	}
}
```

Классы полей должны лежать в подкаталоге `fields`.
Класс поля наследуется от `app\modules\graphql\components\BaseField` и определяет собственные имя, описание, аргументы запроса, содержимый тип данных, и метод получения этих данных.

Классы фильтров ввода должны лежать в подкаталоге `inputs`.
Класс фильтра наследуется от `GraphQL\Type\Definition\InputObjectType` и определяет набор и формат полей, управляющих фильтрацией выборки по этому полю (грубо говоря - как набор GET-параметров в search()-методах).

### Именование классов.

Все классы именуются по нашей стандартной нотации `ИмяСущностиПостфикс`, где постфиксы
- `Type` для классов типа данных;
- `Field` для классов полей;
- `FilterInput` для классов фильтров ввода.

### Чё по коду?

`modules/graphql/components`:
- `AuthHelper` => помогайка для авторизации, переехало из `AuthTrait`. Алсо, добавлен ключик настроек `GRAPHQL_IGNORE_TOKEN_VALIDATION`, позволяющий в отладочных целях игнорировать требование токена в запросе (авторизация идёт от имени текущего пользователя, и работать это будет, очевидно, только в веб-клиенте).
- `BaseObjectType` и `BaseMutationType` - базовые абстрактные классы, позволяющие упростить инстанцирование типов данных и типов мутаций. Избавляют нас от необходимости поддерживать Types.php (он вообще почти испарился, надо дочистить непонятные мне остатки) + добавляют полезные методы вместо хелперов.
- `BaseField` - такая же логика, только для типов полей: упрощаем инстанцирование + полезняхи. Класс имплементит ResolveInterface, все наследники должны иметь реализацию метода `resolve()`

### Что ещё?

Я как следует разобрал только `schema\types`, `shema\mutations` только отрефакторил, чтобы они ушли из Types.php, так что там ещё могут быть изменения. Учитывая, что мутации мы накидывали "лишь бы было, что показать" - нормально.
Какие-то не очень существенные изменения по схемам ещё могут быть, но суть останется примерно такой.

### А если?
![изображение](https://user-images.githubusercontent.com/2357892/129721515-c2004c77-cad0-46f2-97a6-6df7c7c09d13.png)

Тогда смотри, как сделано => делай по аналогии => ты прекрасен.
